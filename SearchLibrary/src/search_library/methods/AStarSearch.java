package search_library.methods;

import java.util.Comparator;
import java.util.HashSet;
import java.util.List;
import java.util.PriorityQueue;

import search_library.AbstractSearchMethod;
import search_library.AbstractSearchNode;


/**
 * Implements the <b>A*</b> star search algorithm. The constructor's parameter
 * "checkRepeatedStates" may be used to choose between two variants:
 * <ol>
 * <li>if it is "<i>false</i>", this class runs a <b>tree search</b> version of
 * A*, that does not check duplicated states (generated by different parent
 * nodes, for example).
 * <li>if it is "<i>true</i>", it runs a <b>graph search</b> version of A*, that
 * keeps a set with all closed (fully explored) states to avoid duplication.
 * </ol>
 * To ensure optimality, the subclass of {@link AbstractSearchNode} should use a
 * heuristic (to estimate the future cost) with this property:
 * <ul>
 * <li><i>admissible</i>, if a tree search is going to be used;
 * <li><i>consistent</i>, if a graph search is going to be used.
 * </ul>
 * 
 * @author Pablo A. Sampaio
 * @author Alison Carrera
 */
public class AStarSearch extends AbstractSearchMethod {
	private boolean showLog;
	private boolean checkRepetition;

	public AStarSearch() {
		this.showLog = false;
		this.checkRepetition = false;
	}

	public AStarSearch(boolean log, boolean checkRepeatedNodes) {
		this.showLog = log;
		this.checkRepetition = checkRepeatedNodes;
	}

	@Override
	protected AbstractSearchNode doSearch(AbstractSearchNode initialState) {

		if (checkRepetition) {
			return doGraphSearch(initialState);
		} else {
			return doTreeSearch(initialState);
		}
	}

	private AbstractSearchNode doTreeSearch(AbstractSearchNode initialState) {
		PriorityQueue<AbstractSearchNode> border = new PriorityQueue<>(new AStarComparator());
		border.add(initialState);

		AbstractSearchNode current;
		int expandedNodes = 0;

		while (!border.isEmpty()) {
			current = border.poll();

			if (showLog) {
				System.out.printf("Selected to expand: %s, cost %d \n", current.toString(),
						current.getFutureCostEstimate());
			}

			if (current.isGoal()) {

				if (showLog) {
					// Mostra Resultado
					List<AbstractSearchNode> result = current.getSolutionPath();
					System.out.println("Result");
					for (AbstractSearchNode showResult : result) {
						System.out.println(showResult.toString());
					}
					System.out.println("Steps count:");
					System.out.println(result.size());
					System.out.println("Expanded Nodes:" + expandedNodes);
				}

				return current;
			}

			for (AbstractSearchNode child : current.expand()) {
				expandedNodes++;
				if (showLog) {
					System.out.printf(" > new child: %s, cost %d \n", child.toString(), child.getFutureCostEstimate());
				}

				border.add(child);
			}

		}

		return null;
	}

	protected AbstractSearchNode doGraphSearch(AbstractSearchNode initialState) {
		HashSet<AbstractSearchNode> closed = new HashSet<>();

		PriorityQueue<AbstractSearchNode> border = new PriorityQueue<>(new AStarComparator());
		border.add(initialState);

		AbstractSearchNode current;
		int expandedNodes = 0;

		while (!border.isEmpty()) {
			current = border.poll();

			// nodes that were expanded once cannot be expanded anymore
			if (closed.contains(current)) {
				continue; // restarts the loop
			}

			closed.add(current);

			if (showLog) {
				System.out.printf("Selected to expand: %s, cost %d \n", current.toString(),
						current.getFutureCostEstimate());
			}

			if (current.isGoal()) {

				if (showLog) {
					// Mostra Resultado
					List<AbstractSearchNode> result = current.getSolutionPath();
					System.out.println("Result");
					for (AbstractSearchNode showResult : result) {
						System.out.println(showResult.toString());
					}
					System.out.println("Steps count:");
					System.out.println(result.size());
					System.out.println("Expanded Nodes:" + expandedNodes);
				}

				return current;
			}

			for (AbstractSearchNode child : current.expand()) {
				// nodes that were expanded once cannot be expanded anymore
				if (!closed.contains(child)) {
					expandedNodes++;
					if (showLog) {
						System.out.printf(" > new child: %s, cost %d \n", child.toString(),
								child.getFutureCostEstimate());
					}

					border.add(child);
				}

			}

		}

		return null;
	}

}

/**
 * 
 * This class implements a comparator that is used on the priority queue
 * ordination.
 *
 */
class AStarComparator implements Comparator<AbstractSearchNode> {

	@Override
	public int compare(AbstractSearchNode o1, AbstractSearchNode o2) {
		if (o1.getFutureCostEstimate() > o2.getFutureCostEstimate()) {
			return 1;
		}
		if (o1.getFutureCostEstimate() < o2.getFutureCostEstimate()) {
			return -1;
		}
		return 0;
	}

}
